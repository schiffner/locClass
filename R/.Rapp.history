help(package = "locClass")
library(locClassData)#
data <- flashData(1000)#
grid <- expand.grid(x.1=seq(-6,6,0.2), x.2=seq(-4,4,0.2))#
#
cluster <- kmeans(data$x, center = 4)$cluster#
model <- FLXMCLconstant()#
fit <- flexmix(y ~ ., data = as.data.frame(data), concomitant = FLXPmultinom(~ x.1 + x.2), model = model, cluster = cluster, control = list(verb = 1))
prediction with aggregation depending on membership in mixture components#
pred.grid <- mypredict(fit, newdata = grid, aggregate = TRUE)#
image(seq(-6,6,0.2), seq(-4,4,0.2), matrix(pred.grid[[1]][,1], length(seq(-6,6,0.2))))#
contour(seq(-6,6,0.2), seq(-4,4,0.2), matrix(pred.grid[[1]][,1], length(seq(-6,6,0.2))), add  = TRUE)#
points(data$x, pch = as.character(data$y))
fit
setMethod("determinePrior", signature(concomitant = "FLXPmultinom"), function (prior, concomitant, group) {#
		x <- concomitant@x %*% concomitant@coef#
		m <- apply(x, 1, max)#
		exps <- exp(x - m)#
		exps/rowSums(exps)#
})
prediction with aggregation depending on membership in mixture components#
pred.grid <- mypredict(fit, newdata = grid, aggregate = TRUE)#
image(seq(-6,6,0.2), seq(-4,4,0.2), matrix(pred.grid[[1]][,1], length(seq(-6,6,0.2))))#
contour(seq(-6,6,0.2), seq(-4,4,0.2), matrix(pred.grid[[1]][,1], length(seq(-6,6,0.2))), add  = TRUE)#
points(data$x, pch = as.character(data$y))
determinePrior <- flexmix:::determinePrior
prediction with aggregation depending on membership in mixture components#
pred.grid <- mypredict(fit, newdata = grid, aggregate = TRUE)#
image(seq(-6,6,0.2), seq(-4,4,0.2), matrix(pred.grid[[1]][,1], length(seq(-6,6,0.2))))#
contour(seq(-6,6,0.2), seq(-4,4,0.2), matrix(pred.grid[[1]][,1], length(seq(-6,6,0.2))), add  = TRUE)#
points(data$x, pch = as.character(data$y))
pred.grid <- mypredict(fit, newdata = grid, aggregate = TRUE)#
image(seq(-6,6,0.2), seq(-4,4,0.2), matrix(pred.grid[[1]][,1], length(seq(-6,6,0.2))))#
contour(seq(-6,6,0.2), seq(-4,4,0.2), matrix(pred.grid[[1]][,1], length(seq(-6,6,0.2))), add  = TRUE)#
points(data$x, pch = as.character(data$y))
fit@concomitant
library(locClasss)
library(locClass)
?nnetModel
library(locClassData)#
#
data <- vData(500)#
x <- seq(0,1,0.05)#
grid <- expand.grid(x.1 = x, x.2 = x)#
#
fit <- mob(y ~ x.1 + x.2 | x.1 + x.2, data = data, model = nnetModel, size = 1, trace = FALSE,#
control = mob_control(objfun = deviance, minsplit = 200))
library(locClassData)#
#
data <- vData(500)#
x <- seq(0,1,0.05)#
grid <- expand.grid(x.1 = x, x.2 = x)#
#
fit <- mob(y ~ x.1 + x.2 | x.1 + x.2, data = data, model = nnetModel, size = 1, trace = FALSE, reps = 2,#
control = mob_control(objfun = deviance, minsplit = 200))
nnetRep
library(locClass)
library(testthat)
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_osqda.R")
fit <- osqda(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = FALSE)
fit
str(fit)
predict(fit)
fit <- osqda(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = 0)
predict(fit)
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_osqda.R")
warnings()
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_ossvm.R")
?expect_equivalent
all classes, correct order#
	data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	k <- 100#
	n <- 90#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)
pred1
pred2
all classes, but different order 1#
	data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	perm <- 150:1  ## 3, 2, 1#
	iris <- iris[perm,]#
	k = 100#
	n <- 90#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	expect_equivalent(pred1, pred2)
pred1
pred2
expect_equal(attr(pred1, "probabilities"), attr(pred2, "probabilities")[,3:1, drop = FALSE])	#
	expect_equal(as.vector(attr(pred1, "decision.values")), -as.vector(attr(pred2, "decision.values")[,3:1]))
attr(pred1, "probabilities")
attr(pred2, "probabilities")[,3:1, drop = FALSE]
expect_equal(as.vector(attr(pred1, "decision.values")), -as.vector(attr(pred2, "decision.values")[,3:1]))
data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	perm <- c(150:101,1:100)  ## 3, 1, 2#
	iris <- iris[perm,]#
	k = 100#
	n <- 90#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	expect_equivalent(pred1, pred2)	#
	expect_equal(attr(pred1, "probabilities"), attr(pred2, "probabilities")[,c(3,1,2), drop = FALSE])	#
	expect_equivalent(c(1,-1,-1)*attr(pred1, "decision.values")[c(3,1,2)], as.vector(attr(pred2, "decision.values")))
context("ossvm")#
#
test_that("ossvm: misspecified arguments", {#
	data(iris)#
	# wrong variable names#
	expect_error(ossvm(formula = Species ~ V1, data = iris, wf = "gaussian", bw = 10))#
	# wrong class#
	expect_error(ossvm(formula = iris, data = iris, wf = "gaussian", bw = 10))#
	expect_error(ossvm(iris, data = iris, wf = "gaussian", bw = 10))#
	# target variable also in x#
	expect_error(ossvm(y = iris$Species, x = iris, wf = "gaussian", bw = 10))#
	expect_warning(ossvm(Species ~ Species + Petal.Width, data = iris, wf = "gaussian", bw = 10))           ## warning, Species on RHS removed#
	# missing x#
	expect_error(ossvm(y = iris$Species, wf = "gaussian", bw = 10))#
})#
# test_that("ossvm throws a warning if y variable is numeric", {#
	# data(iris)#
	# formula, data#
	# expect_that(ossvm(formula = as.numeric(Species) ~ ., data = iris, wf = "gaussian", bw = 10), gives_warning("'y' was coerced to a factor"))#
	# y, x#
	# expect_that(ossvm(y = iris[,1], x = iris[,-1], wf = "gaussian", bw = 10), gives_warning("'y' was coerced to a factor"))#
# })#
test_that("ossvm works if only one predictor variable is given", {#
	data(iris)#
	fit <- ossvm(Species ~ Petal.Width, data = iris, wf = "gaussian", bw = 5)#
	predict(fit)#
})#
test_that("ossvm: training data from only one class", {#
	data(iris)#
	expect_that(ossvm(Species ~ ., data = iris, bw = 2, subset = 1:50), throws_error("training data from only one class"))#
	expect_error(ossvm(Species ~ ., data = iris, bw = 2, subset = 1))#
	expect_that(ossvm(y = iris$Species, x = iris[,-5], bw = 2, subset = 1:50), throws_error("training data from only one class"))#
	expect_error(ossvm(y = iris$Species, x = iris[,-5], bw = 2, subset = 1))#
})#
test_that("ossvm: subsetting works", {#
	data(iris)#
	# formula, data#
	expect_that(fit1 <- ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 2, subset = 1:80), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- ossvm(Species ~ ., data = iris[1:80,], wf = "gaussian", bw = 2), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-1],fit2[-1])#
	expect_equal(nrow(fit1$x), 80)#
	expect_equal(length(fit1$y), 80)#
	# x, y#
	expect_that(fit1 <- ossvm(y = iris$Species, x = iris[,-5], wf = "gaussian", bw = 2, subset = 1:80), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- ossvm(y = iris$Species[1:80], x = iris[1:80,-5], wf = "gaussian", bw = 2), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-1],fit2[-1])#
	expect_equal(nrow(fit1$x), 80)#
	expect_equal(length(fit1$y), 80)#
	# wrong specification of subset argument#
	expect_error(ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = iris[1:10,]))#
	expect_error(ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = FALSE)) #???#
	expect_error(ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = 0)) #???#
	expect_error(ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = -10:50))#
})#
test_that("ossvm: NA handling works correctly", {#
	### NA in x#
	data(iris)#
	irisna <- iris#
	irisna[1:10, c(1,3)] <- NA#
	## formula, data#
	# na.fail#
	expect_that(ossvm(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 6:60, na.action = na.fail), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- ossvm(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 6:60, na.action = na.omit), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- ossvm(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 11:60), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-c(1:2,31)], fit2[-c(1:2,31)])#
	expect_equivalent(fit1[2], fit2[2])#
#
	## x, y#
	# na.fail#
	expect_that(ossvm(y = irisna$Species, x = irisna[,-5], wf = "gaussian", bw = 10, subset = 6:60, na.action = na.fail), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- ossvm(y = irisna$Species, x = irisna[,-5], wf = "gaussian", bw = 10, subset = 6:60, na.action = na.omit), gives_warning("group virginica is empty"))###
	expect_that(fit2 <- ossvm(y = irisna$Species, x = irisna[,-5], wf = "gaussian", bw = 10, subset = 11:60), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-c(1:2,31)], fit2[-c(1:2,31)])#
	expect_equivalent(fit1[2], fit2[2])#
	### NA in y#
	irisna <- iris#
	irisna$Species[1:10] <- NA#
	## formula, data#
	# na.fail#
	expect_that(ossvm(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 6:60, na.action = na.fail), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- ossvm(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 6:60, na.action = na.omit), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- ossvm(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 11:60), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-c(1:2,31)], fit2[-c(1:2,31)])#
	expect_equivalent(fit1[2], fit2[2])#
	## x, y#
	# na.fail#
	expect_that(ossvm(y = irisna$Species, x = irisna[,-5], wf = "gaussian", bw = 10, subset = 6:60, na.action = na.fail), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- ossvm(y = irisna$Species, x = irisna[,-5], wf = "gaussian", bw = 10, subset = 6:60, na.action = na.omit), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- ossvm(y = irisna$Species, x = irisna[,-5], wf = "gaussian", bw = 10, subset = 11:60), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-c(1:2,31)], fit2[-c(1:2,31)])#
	expect_equivalent(fit1[2], fit2[2])#
#
	### NA in subset#
	subset <- 6:60#
	subset[1:5] <- NA#
	## formula, data#
	# na.fail#
	expect_that(ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = subset, na.action = na.fail), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = subset, na.action = na.omit), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = 11:60), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-c(1:2,31)], fit2[-c(1:2,31)])#
	expect_equivalent(fit1[2], fit2[2])#
	## x, y#
	# na.fail#
	expect_that(ossvm(y = iris$Species, x = iris[,-5], wf = "gaussian", bw = 10, subset = subset, na.action = na.fail), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- ossvm(y = iris$Species, x = iris[,-5], wf = "gaussian", bw = 10, subset = subset, na.action = na.omit), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- ossvm(y = iris$Species, x = iris[,-5], wf = "gaussian", bw = 10, subset = 11:60), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-c(1:2,31)], fit2[-c(1:2,31)])#
	expect_equivalent(fit1[2], fit2[2])#
})#
test_that("ossvm: try all weight functions", {#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = 2, probability = TRUE)    #
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = gaussian(2), probability = TRUE)    #
	fit3 <- ossvm(x = iris[,-5], y = iris$Species, wf = "gaussian", bw = 2, probability = TRUE)    #
	fit4 <- ossvm(x = iris[,-5], y = iris$Species, wf = gaussian(2), probability = TRUE)    #
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit3[-c(1,4)], fit4[-c(1,4)])#
	expect_equal(fit2[-c(1,2,32)], fit4[-c(1,2)])#
	expect_equivalent(fit2[2], fit4[2])#
	pred1 <- predict(fit1, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, probability = TRUE, decision.values = TRUE)#
	pred4 <- predict(fit4, probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred3, pred4)#
	expect_equal(pred2, pred4)#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = 5, k = 30, probability = TRUE)    #
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = gaussian(bw = 5, k = 30), probability = TRUE)    #
	fit3 <- ossvm(x = iris[,-5], y = iris$Species, wf = "gaussian", bw = 5, k = 30, probability = TRUE)    #
	fit4 <- ossvm(x = iris[,-5], y = iris$Species, wf = gaussian(bw = 5, k = 30), probability = TRUE)#
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit3[-c(1,4)], fit4[-c(1,4)])#
	expect_equal(fit2[-c(1,2,32)], fit4[-c(1,2)])#
	expect_equivalent(fit2[2], fit4[2])#
	pred1 <- predict(fit1, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, probability = TRUE, decision.values = TRUE)#
	pred4 <- predict(fit4, probability = TRUE, decision.values = TRUE)#
	# pred1 <- predict(fit1, newdata = iris[sample(1:150),], probability = TRUE, decision.values = TRUE)#
	# pred2 <- predict(fit2, newdata = iris[1:10,], probability = TRUE, decision.values = TRUE)#
	# pred3 <- predict(fit3, newdata = iris[1,-5], probability = TRUE, decision.values = TRUE)#
	# pred4 <- predict(fit4, newdata = iris[1,-5], probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred3, pred4)#
	expect_equal(pred2, pred4)#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "epanechnikov", bw = 5, k = 30, probability = TRUE)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = epanechnikov(bw = 5, k = 30), probability = TRUE)#
	fit3 <- ossvm(x = iris[,-5], y = iris$Species, wf = "epanechnikov", bw = 5, k = 30, probability = TRUE)#
	fit4 <- ossvm(x = iris[,-5], y = iris$Species, wf = epanechnikov(5, 30), probability = TRUE)    #
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit3[-c(1,4)], fit4[-c(1,4)])#
	expect_equal(fit2[-c(1,2,32)], fit4[-c(1,2)])#
	expect_equivalent(fit2[2], fit4[2])#
	pred1 <- predict(fit1, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, probability = TRUE, decision.values = TRUE)#
	pred4 <- predict(fit4, probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred3, pred4)#
	expect_equal(pred2, pred4)#
#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "rectangular", bw = 5, k = 30, probability = TRUE)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = rectangular(bw = 5, k = 30), probability = TRUE)#
	fit3 <- ossvm(x = iris[,-5], y = iris$Species, wf = "rectangular", bw = 5, k = 30, probability = TRUE)#
	fit4 <- ossvm(x = iris[,-5], y = iris$Species, wf = rectangular(5, 30), probability = TRUE)    #
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit3[-c(1,4)], fit4[-c(1,4)])#
	expect_equal(fit2[-c(1,2,32)], fit4[-c(1,2)])#
	expect_equivalent(fit2[2], fit4[2])#
	pred1 <- predict(fit1, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, probability = TRUE, decision.values = TRUE)#
	pred4 <- predict(fit4, probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred3, pred4)#
	expect_equal(pred2, pred4)#
#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "triangular", bw = 5, k = 30, probability = TRUE)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = triangular(5, k = 30), probability = TRUE)#
	fit3 <- ossvm(x = iris[,-5], y = iris$Species, wf = "triangular", bw = 5, k = 30, probability = TRUE)#
	fit4 <- ossvm(x = iris[,-5], y = iris$Species, wf = triangular(5, 30), probability = TRUE)    #
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit3[-c(1,4)], fit4[-c(1,4)])#
	expect_equal(fit2[-c(1,2,32)], fit4[-c(1,2)])#
	expect_equivalent(fit2[2], fit4[2])#
	pred1 <- predict(fit1, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, probability = TRUE, decision.values = TRUE)#
	pred4 <- predict(fit4, probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred3, pred4)#
	expect_equal(pred2, pred4)#
#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "biweight", bw = 5, probability = TRUE)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = biweight(5), probability = TRUE)#
	fit3 <- ossvm(x = iris[,-5], y = iris$Species, wf = "biweight", bw = 5, probability = TRUE)#
	fit4 <- ossvm(x = iris[,-5], y = iris$Species, wf = biweight(5), probability = TRUE)    #
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit3[-c(1,4)], fit4[-c(1,4)])#
	expect_equal(fit2[-c(1,2,32)], fit4[-c(1,2)])#
	expect_equivalent(fit2[2], fit4[2])#
	pred1 <- predict(fit1, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, probability = TRUE, decision.values = TRUE)#
	pred4 <- predict(fit4, probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred3, pred4)#
	expect_equal(pred2, pred4)#
#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "optcosine", bw = 5, k = 30, probability = TRUE)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = optcosine(5, k = 30), probability = TRUE)#
	fit3 <- ossvm(x = iris[,-5], y = iris$Species, wf = "optcosine", bw = 5, k = 30, probability = TRUE)#
	fit4 <- ossvm(x = iris[,-5], y = iris$Species, wf = optcosine(5, 30), probability = TRUE)    #
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit3[-c(1,4)], fit4[-c(1,4)])#
	expect_equal(fit2[-c(1,2,32)], fit4[-c(1,2)])#
	expect_equivalent(fit2[2], fit4[2])#
	pred1 <- predict(fit1, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, probability = TRUE, decision.values = TRUE)#
	pred4 <- predict(fit4, probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred3, pred4)#
	expect_equal(pred2, pred4)#
#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "cosine", bw = 5, k = 30, probability = TRUE)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = cosine(5, k = 30), probability = TRUE)#
	fit3 <- ossvm(x = iris[,-5], y = iris$Species, wf = "cosine", bw = 5, k = 30, probability = TRUE)#
	fit4 <- ossvm(x = iris[,-5], y = iris$Species, wf = cosine(5, 30), probability = TRUE)    #
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit3[-c(1,4)], fit4[-c(1,4)])#
	expect_equal(fit2[-c(1,2,32)], fit4[-c(1,2)])#
	expect_equivalent(fit2[2], fit4[2])#
	pred1 <- predict(fit1, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, probability = TRUE, decision.values = TRUE)#
	pred4 <- predict(fit4, probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred3, pred4)#
	expect_equal(pred2, pred4)#
})#
test_that("ossvm: local solution with rectangular window function and large bw and global solution coincide", {#
	data(iris)#
	library(e1071)#
	## newdata missing#
	fit1 <- wsvm(formula = Species ~ ., data = iris)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = rectangular(20))#
	fit3 <- svm(Species ~ ., data = iris)#
	pred1 <- predict(fit1)#
	pred2 <- predict(fit2)#
	pred3 <- predict(fit3)#
	expect_equal(pred1, pred2)#
	expect_equal(pred1, pred3)#
	## newdata given#
	fit1 <- wsvm(formula = Species ~ ., data = iris, probability = TRUE)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = rectangular(8), probability = TRUE)#
	fit3 <- svm(Species ~ ., data = iris, probability = TRUE)#
	pred1 <- predict(fit1, newdata = iris, probability = TRUE, decision.values = TRUE)#
	pred2 <- predict(fit2, newdata = iris, probability = TRUE, decision.values = TRUE)#
	pred3 <- predict(fit3, newdata = iris, probability = TRUE, decision.values = TRUE)#
	# pred1 <- predict(fit1, newdata = iris[1,], probability = TRUE, decision.values = TRUE)#
	# pred2 <- predict(fit2, newdata = iris[1,], probability = TRUE, decision.values = TRUE)#
	# pred3 <- predict(fit3, newdata = iris[1,], probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)#
	expect_equal(pred1, pred3)#
	expect_equal(pred2, pred3)#
})#
test_that("ossvm: labels vector set correctly",{#
#
	## all classes, correct order#
	data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	k <- 100#
	n <- 90#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	expect_equal(pred1, pred2)				# not exactly equal#
#
	## all classes, but different order 1#
	data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	perm <- 150:1  ## 3, 2, 1#
	iris <- iris[perm,]#
	k = 100#
	n <- 90#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	expect_equivalent(pred1, pred2)	#
	expect_equal(attr(pred1, "probabilities"), attr(pred2, "probabilities")[,3:1, drop = FALSE])				# not exactly equal	#
	expect_equal(as.vector(attr(pred1, "decision.values")), -as.vector(attr(pred2, "decision.values")[,3:1]))	#
	## all classes, but different order 2#
	data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	perm <- c(150:101,1:100)  ## 3, 1, 2#
	iris <- iris[perm,]#
	k = 100#
	n <- 90#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	expect_equivalent(pred1, pred2)	#
	expect_equal(attr(pred1, "probabilities"), attr(pred2, "probabilities")[,c(3,1,2), drop = FALSE])	#
	expect_equivalent(c(1,-1,-1)*attr(pred1, "decision.values")[c(3,1,2)], as.vector(attr(pred2, "decision.values")))#
	## 2 classes, correct order#
	data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	k <- 50#
	n <- 90#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	expect_equivalent(pred1, pred2)	#
	expect_equal(attr(pred1, "probabilities"), attr(pred2, "probabilities")[,colnames(attr(pred1, "probabilities")), drop = FALSE])	#
	expect_equal(as.numeric(attr(pred1, "decision.values")), attr(pred2, "decision.values")[,!is.na(attr(pred2, "decision.values"))])	#
	## 2 classes, but different order 1#
	data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	perm <- 150:1#
	iris <- iris[perm,]#
	k <- 40#
	n <- 99#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)#
	expect_equivalent(pred1, pred2)#
	expect_equal(attr(pred1, "probabilities"), attr(pred2, "probabilities")[,colnames(attr(pred1, "probabilities")), drop = FALSE])	#
	expect_equal(as.numeric(attr(pred1, "decision.values")), -attr(pred2, "decision.values")[!is.na(attr(pred2, "decision.values"))])#
#
	## 2 classes, but different order 2#
	data(iris)#
	iris[,1:4] <- scale(iris[,1:4])#
	perm <- c(150:101,1:100)#
	iris <- iris[perm,]#
	k <- 50#
	n <- 90#
	x <- as.matrix(iris[,-5])#
	dist <- sqrt(colSums((t(x) - x[n,])^2))#
	w <- rectangular(k = k)(dist)#
	fit1 <- wsvm(Species ~ ., data = iris, case.weights = w/sum(w) * 150, probability = TRUE, scale = FALSE)#
	pred1 <- predict(fit1, newdata = iris[n,], probability = TRUE, decision.values = TRUE)	#
	fit2 <- ossvm(Species ~ ., data = iris, probability = TRUE, wf = "rectangular", k = k, scale = FALSE)#
	pred2 <- predict(fit2, newdata = iris[n,], probability = TRUE, decision.values = TRUE)	#
	expect_equivalent(pred1, pred2)#
	expect_equal(attr(pred1, "probabilities"), attr(pred2, "probabilities")[,colnames(attr(pred1, "probabilities")), drop = FALSE])	#
	expect_equal(as.numeric(attr(pred1, "decision.values")), attr(pred2, "decision.values")[!is.na(attr(pred2, "decision.values"))])#
})#
test_that("ossvm: arguments related to weighting misspecified", {#
	# bw, k not required#
	expect_that(fit1 <- ossvm(Species ~ ., data = iris, wf = gaussian(0.5), k = 30, bw = 0.5), gives_warning(c("argument 'k' is ignored", "argument 'bw' is ignored")))#
	fit2 <- ossvm(Species ~ ., data = iris, wf = gaussian(0.5))#
	expect_equal(fit1[-1], fit2[-1])#
#
	expect_that(fit1 <- ossvm(Species ~ ., data = iris, wf = gaussian(0.5), bw = 0.5), gives_warning("argument 'bw' is ignored"))	#
	fit2 <- ossvm(Species ~ ., data = iris, wf = gaussian(0.5))#
	expect_equal(fit1[-1], fit2[-1])#
	expect_equal(fit1$k, NULL)#
	expect_equal(fit1$nn.only, NULL)	#
	expect_equal(fit1$bw, 0.5)	#
	expect_equal(fit1$adaptive, FALSE)	#
#
	expect_that(fit1 <- ossvm(Species ~ ., data = iris, wf = function(x) exp(-x), bw = 0.5, k = 30), gives_warning(c("argument 'k' is ignored", "argument 'bw' is ignored")))#
	expect_that(fit2 <- ossvm(Species ~ ., data = iris, wf = function(x) exp(-x), k = 30), gives_warning("argument 'k' is ignored"))#
	expect_equal(fit1[-1], fit2[-1])#
	expect_equal(fit1$k, NULL)#
	expect_equal(fit1$nn.only, NULL)	#
	expect_equal(fit1$bw, NULL)	#
	expect_equal(fit1$adaptive, NULL)	#
#
	expect_that(fit1 <- ossvm(Species ~ ., data = iris, wf = function(x) exp(-x), bw = 0.5), gives_warning("argument 'bw' is ignored"))#
	fit2 <- ossvm(Species ~ ., data = iris, wf = function(x) exp(-x))#
	expect_equal(fit1[-1], fit2[-1])#
	expect_equal(fit1$k, NULL)#
	expect_equal(fit1$nn.only, NULL)	#
	expect_equal(fit1$bw, NULL)	#
	expect_equal(fit1$adaptive, NULL)	#
#
	# missing quotes#
	fit <- ossvm(formula = Species ~ ., data = iris, wf = gaussian) ## error because length(weights) and nrow(x) are different#
	expect_error(predict(fit))#
	# bw, k missing#
	expect_that(ossvm(formula = Species ~ ., data = iris, wf = gaussian()), throws_error("either 'bw' or 'k' have to be specified"))#
	expect_that(ossvm(formula = Species ~ ., data = iris, wf = gaussian(), k = 10), throws_error("either 'bw' or 'k' have to be specified"))#
	expect_that(ossvm(Species ~ ., data = iris), throws_error("either 'bw' or 'k' have to be specified"))#
	# bw < 0#
	expect_that(ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = -5), throws_error("'bw' must be positive"))#
	expect_that(ossvm(formula = Species ~ ., data = iris, wf = "cosine", k = 10, bw = -50), throws_error("'bw' must be positive"))#
	# bw vector#
	expect_that(ossvm(formula = Species ~., data = iris, wf = "gaussian", bw = rep(1, nrow(iris))), gives_warning("only first element of 'bw' used"))#
	# k < 0#
	expect_that(ossvm(formula = Species ~ ., data = iris, wf = "gaussian", k =-7, bw = 50), throws_error("'k' must be positive"))#
#
	# k too small#
	#fit <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", k = 5, bw = 0.005)#
	#expect_equal(length(is.na(predict(fit)$class)), 150)#
#
	# k too large#
	expect_that(ossvm(formula = Species ~ ., data = iris, k = 250, wf = "gaussian", bw = 50), throws_error("'k' is larger than 'n'"))#
#
	# k vector#
	expect_that(ossvm(formula = Species ~., data = iris, wf = "gaussian", k = rep(50, nrow(iris))), gives_warning("only first element of 'k' used"))#
})#
test_that("ossvm: weighting schemes work", {#
	## wf with finite support#
	# fixed bw#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "rectangular", bw = 5)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = rectangular(bw = 5))#
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit1$bw, 5)#
	expect_equal(fit1$k, NULL)#
	expect_equal(fit1$nn.only, NULL)#
	expect_true(!fit1$adaptive)#
#
	# adaptive bw, only knn #
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "rectangular", k = 50)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = rectangular(k = 50))#
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit1$k, 50)#
	expect_equal(fit1$bw, NULL)#
	expect_true(fit1$nn.only)#
	expect_true(fit1$adaptive)#
#
	# fixed bw, only knn#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "rectangular", bw = 5, k = 50)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = rectangular(bw = 5, k = 50))#
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit1$bw, 5)#
	expect_equal(fit1$k, 50)#
	expect_true(fit1$nn.only)#
	expect_true(!fit1$adaptive)#
	# nn.only not needed#
	expect_that(ossvm(formula = Species ~ ., data = iris, wf = "rectangular", bw = 5, nn.only = TRUE), gives_warning("argument 'nn.only' is ignored"))#
#
	# nn.only has to be TRUE if bw and k are both given#
	expect_that(ossvm(formula = Species ~ ., data = iris, wf = "rectangular", bw = 5, k = 50, nn.only = FALSE), throws_error("if 'bw' and 'k' are given argument 'nn.only' must be TRUE"))#
	## wf with infinite support#
	# fixed bw#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = 0.5)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = gaussian(bw = 0.5))#
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit1$bw, 0.5)#
	expect_equal(fit1$k, NULL)#
	expect_equal(fit1$nn.only, NULL)#
	expect_true(!fit1$adaptive)#
#
	# adaptive bw, only knn#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", k = 50)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = gaussian(k = 50))#
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit1$bw, NULL)#
	expect_equal(fit1$k, 50)#
	expect_equal(fit1$nn.only, TRUE)#
	expect_true(fit1$adaptive)#
#
	# adaptive bw, all obs#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", k = 50, nn.only = FALSE)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = gaussian(k = 50, nn.only = FALSE))#
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit1$bw, NULL)#
	expect_equal(fit1$k, 50)#
	expect_equal(fit1$nn.only, FALSE)#
	expect_true(fit1$adaptive)#
#
	# fixed bw, only knn#
	fit1 <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = 1, k = 50)#
	fit2 <- ossvm(formula = Species ~ ., data = iris, wf = gaussian(bw = 1, k = 50))#
	expect_equal(fit1[-c(1,4)], fit2[-c(1,4)])#
	expect_equal(fit1$bw, 1)#
	expect_equal(fit1$k, 50)#
	expect_equal(fit1$nn.only, TRUE)#
	expect_true(!fit1$adaptive)#
	# nn.only has to be TRUE if bw and k are both given#
	expect_that(ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = 1, k = 50, nn.only = FALSE), throws_error("if 'bw' and 'k' are given argument 'nn.only' must be TRUE"))#
})	#
#=================================================================================================================#
context("predict.ossvm")#
#
test_that("predict.ossvm works correctly with formula and data.frame interface and with missing newdata", {#
	data(iris)#
	ran <- sample(1:150,100)#
	## formula, data#
	fit <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = 2, subset = ran, probability = TRUE)#
  	pred <- predict(fit)#
  	pred2 <- predict(fit, newdata = iris[ran,])   ######
  	expect_equal(names(pred), rownames(iris)[ran])  	#
	## formula, data, newdata#
  	pred <- predict(fit, newdata = iris[-ran,], probability = TRUE, decision.values = TRUE)#
  	expect_equal(names(pred), rownames(iris)[-ran])  	#
  	expect_equal(rownames(attr(pred, "probabilities")), rownames(iris)[-ran])  	#
  	expect_equal(rownames(attr(pred, "decision.values")), rownames(iris)[-ran])  	#
	## y, x#
	fit <- ossvm(x = iris[ran,-5], y = iris$Species[ran], wf = "gaussian", bw = 2, probability = TRUE)  #
  	pred <- predict(fit)#
  	expect_equal(names(pred), rownames(iris)[ran])  	#
	## y, x, newdata#
  	pred <- predict(fit, newdata = iris[-ran,-5], probability = TRUE, decision.values = TRUE)#
  	expect_equal(names(pred), rownames(iris)[-ran])  	#
  	expect_equal(rownames(attr(pred, "probabilities")), rownames(iris)[-ran])  	#
  	expect_equal(rownames(attr(pred, "decision.values")), rownames(iris)[-ran])  	#
})#
test_that("predict.ossvm: retrieving training data works", {#
	data(iris)#
	## no subset#
	# formula, data#
	fit <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = 2)#
  	pred1 <- predict(fit)#
  	pred2 <- predict(fit, newdata = iris)#
  	expect_equal(pred1, pred2)#
	# y, x#
	fit <- ossvm(x = iris[,-5], y = iris$Species, wf = "gaussian", bw = 2)  #
  	pred1 <- predict(fit)#
  	pred2 <- predict(fit, newdata = iris[,-5])#
  	expect_equal(pred1, pred2)#
	## subset#
	ran <- sample(1:150,100)#
	# formula, data#
	fit <- ossvm(formula = Species ~ ., data = iris, wf = "gaussian", bw = 2, subset = ran)#
  	pred1 <- predict(fit)#
  	pred2 <- predict(fit, newdata = iris[ran,])#
  	expect_equal(pred1, pred2)#
	# y, x#
	fit <- ossvm(x = iris[ran,-5], y = iris$Species[ran], wf = "gaussian", bw = 2)  #
  	pred1 <- predict(fit)#
  	pred2 <- predict(fit, newdata = iris[ran,-5])#
  	expect_equal(pred1, pred2)#
})#
test_that("predict.ossvm works with missing classes in the training data", {#
	data(iris)#
	ran <- sample(1:150,100)#
	expect_that(fit <- ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = 1:100, probability = TRUE), gives_warning("group virginica is empty"))#
	expect_equal(length(fit$y), 100)#
	expect_equal(nrow(fit$x), 100)#
	expect_equal(fit$nclass, 2)#
	pred <- predict(fit, newdata = iris[-ran,], probability = TRUE, decision.values = TRUE)#
	expect_equal(nlevels(pred), 3)#
	expect_equal(ncol(attr(pred, "probabilities")), 2)#
	expect_equal(ncol(attr(pred, "decision.values")), 1)#
})#
test_that("predict.ossvm works with one single predictor variable", {#
	data(iris)#
	ran <- sample(1:150,100)#
	fit <- ossvm(Species ~ Petal.Width, data = iris, wf = "gaussian", bw = 2, subset = ran, probability = TRUE)#
	expect_equal(ncol(fit$x), 1)#
	predict(fit, newdata = iris[-ran,], probability = TRUE, decision.values = TRUE)#
})#
test_that("predict.ossvm works with one single test observation", {#
	data(iris)#
	ran <- sample(1:150,100)#
	fit <- ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 2, subset = ran, probability = TRUE)#
  	pred <- predict(fit, newdata = iris[5,])#
	expect_equal(length(pred), 1)#
	a <- factor("setosa", levels = c("setosa", "versicolor", "virginica"))#
	names(a) = "5"#
	expect_equal(pred, a)#
  	pred <- predict(fit, newdata = iris[5,], probability = TRUE, decision.values = TRUE)#
	expect_equal(length(pred), 1)#
	expect_equal(dim(attr(pred, "probabilities")), c(1, 3))#
	expect_equal(dim(attr(pred, "decision.values")), c(1, 3))#
	pred <- predict(fit, newdata = iris[58,])#
	expect_equal(length(pred), 1)#
	a <- factor("versicolor", levels = c("setosa", "versicolor", "virginica"))#
	names(a) = "58"#
	expect_equal(pred, a)#
	pred <- predict(fit, newdata = iris[58,], probability = TRUE, decision.values = TRUE)#
	expect_equal(length(pred), 1)#
	expect_equal(dim(attr(pred, "probabilities")), c(1, 3))#
	expect_equal(dim(attr(pred, "decision.values")), c(1, 3))#
})	#
test_that("predict.ossvm works with one single predictor variable and one single test observation", {#
	data(iris)#
	ran <- sample(1:150,100)#
	fit <- ossvm(Species ~ Petal.Width, data = iris, wf = "gaussian", bw = 2, subset = ran, probability = TRUE)#
	expect_equal(ncol(fit$x), 1)#
	pred <- predict(fit, newdata = iris[5,], probability = TRUE, decision.values = TRUE)#
	expect_equal(length(pred), 1)#
	expect_equal(dim(attr(pred, "probabilities")), c(1, 3))#
	expect_equal(dim(attr(pred, "decision.values")), c(1, 3))#
})#
test_that("predict.ossvm: NA handling in newdata works", {#
	data(iris)#
	ran <- sample(1:150,100)#
	irisna <- iris#
	irisna[1:17,c(1,3)] <- NA#
	fit <- ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 50, subset = ran, probability = TRUE)#
	## na.omit#
	pred <- predict(fit, newdata = irisna, na.action = na.omit, probability = TRUE, decision.values = TRUE)#
	expect_equal(length(pred), 133)#
	expect_equal(names(pred), as.character(18:150))#
	expect_equal(nrow(attr(pred, "probabilities")), 133)#
	expect_equal(rownames(attr(pred, "probabilities")), as.character(18:150))#
	expect_equal(nrow(attr(pred, "decision.values")), 133)#
	expect_equal(rownames(attr(pred, "decision.values")), as.character(18:150))#
	## na.fail#
	expect_that(predict(fit, newdata = irisna, na.action = na.fail, probability = TRUE, decision.values = TRUE), throws_error("missing values in object"))#
})#
test_that("predict.ossvm: misspecified arguments", {#
	data(iris)#
	ran <- sample(1:150,100)#
	fit <- ossvm(Species ~ ., data = iris, wf = "gaussian", bw = 2, subset = ran)#
    # errors in newdata#
    expect_error(predict(fit, newdata = TRUE))#
    expect_error(predict(fit, newdata = -50:50))#
})
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_osmultinom.R")
osmultinom(formula = iris, data = iris, wf = "gaussian", bw = 10, trace = FALSE)
osmultinom(iris, data = iris, wf = "gaussian", bw = 10,  trace = FALSE)
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_osmultinom.R")
NA in x#
	data(iris)#
	irisna <- iris#
	irisna[1:10, c(1,3)] <- NA#
	## formula, data#
	# na.fail#
	expect_that(osmultinom(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 6:60, na.action = na.fail,  trace = FALSE), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- osmultinom(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 6:60, na.action = na.omit,  trace = FALSE), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- osmultinom(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 11:60,  trace = FALSE), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-c(28,34)], fit2[-28])
irisna <- iris#
	irisna$Species[1:10] <- NA#
	## formula, data#
	# na.fail#
	expect_that(osmultinom(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 6:60, na.action = na.fail,  trace = FALSE), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- osmultinom(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 6:60, na.action = na.omit,  trace = FALSE), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- osmultinom(Species ~ ., data = irisna, wf = "gaussian", bw = 10, subset = 11:60,  trace = FALSE), gives_warning("group virginica is empty"))#
	expect_equal(fit1[-c(28,34)], fit2[-28])
NA in subset#
	subset <- 6:60#
	subset[1:5] <- NA#
	## formula, data#
	# na.fail#
	expect_that(osmultinom(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = subset, na.action = na.fail,  trace = FALSE), throws_error("missing values in object"))#
	# check if na.omit works correctly#
	expect_that(fit1 <- osmultinom(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = subset, na.action = na.omit,  trace = FALSE), gives_warning("group virginica is empty"))#
	expect_that(fit2 <- osmultinom(Species ~ ., data = iris, wf = "gaussian", bw = 10, subset = 11:60,  trace = FALSE), gives_warning("group virginica is empty"))
expect_equal(fit1[-c(28,34)], fit2[-28])
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_osmultinom.R")
Wts = runif(n = 18, -0.5, 0.5)#
#
	fit1 <- osmultinom(formula = Species ~ ., data = iris, wf = "gaussian", bw = 5, Wts = Wts,  trace = FALSE)    #
	fit2 <- osmultinom(formula = Species ~ ., data = iris, wf = gaussian(5), Wts = Wts,  trace = FALSE)    #
	expect_equal(fit1[-c(21,28)], fit2[-c(21,28)])
names(fit1)
Wts = runif(n = 18, -0.5, 0.5)#
#
	fit1 <- osmultinom(formula = Species ~ ., data = iris, wf = "gaussian", bw = 5, Wts = Wts,  trace = FALSE)    #
	fit2 <- osmultinom(formula = Species ~ ., data = iris, wf = gaussian(5), Wts = Wts,  trace = FALSE)    #
	expect_equal(fit1[-c(22,28)], fit2[-c(22,28)])
pred1 <- predict(fit1)#
	pred2 <- predict(fit2)#
	expect_equal(pred1, pred2)
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_osmultinom.R")
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_oslda.R")
fit <- mob(Petal.Width ~ . | Sepal.Length, data = iris, model = svmModel, kernel = "linear", fitted = FALSE,#
		control = mob_control(objfun = deviance, minsplit = 20, verbose = TRUE))
iris$Species <- as.numeric(iris$Species)#
	fit <- mob(Species ~ . | Sepal.Length, data = iris, model = svmModel, kernel = "linear", fitted = FALSE,#
		control = mob_control(objfun = deviance, minsplit = 20, verbose = TRUE))
warnings()
fit
data(iris)
expect_that(fit <- mob(Species ~ Sepal.Width | Sepal.Length, data = iris, model = svmModel, kernel = "linear", fitted = FALSE,#
		control = mob_control(objfun = deviance, minsplit = 20, verbose = TRUE)), gives_warning("some groups are empty"))
fit
root.matrix <- function (X) {#
	if ((ncol(X) == 1) && (nrow(X) == 1)) #
		return(sqrt(X))#
	else {#
		X.eigen <- eigen(X, symmetric = TRUE)#
# print(X.eigen$values)#
		index <- X.eigen$values < 0 #
		if (any(index)) {#
			warning("matrix is not positive semidefinite")#
			X.eigen$values[index] <- pmin(min(X.eigen$values[!index]), abs(X.eigen$values[index]))#
		}#
# print(X.eigen$values)#
		sqomega <- sqrt(diag(X.eigen$values))#
		V <- X.eigen$vectors#
# print(X)#
# omega <- diag(X.eigen$values)#
# print(b<<-V %*% omega %*% t(V))#
		return(V %*% sqomega %*% t(V))#
	}#
}
root.matrix <- function (X) {#
	if ((ncol(X) == 1) && (nrow(X) == 1)) #
		return(sqrt(X))#
	else {#
		X.eigen <- eigen(X, symmetric = TRUE)#
print(X.eigen$values)#
		index <- X.eigen$values < 0 #
		if (any(index)) {#
			warning("matrix is not positive semidefinite")#
			X.eigen$values[index] <- pmin(min(X.eigen$values[!index]), abs(X.eigen$values[index]))#
		}#
# print(X.eigen$values)#
		sqomega <- sqrt(diag(X.eigen$values))#
		V <- X.eigen$vectors#
# print(X)#
# omega <- diag(X.eigen$values)#
# print(b<<-V %*% omega %*% t(V))#
		return(V %*% sqomega %*% t(V))#
	}#
}
fit <- mob(Species ~ Sepal.Width | Sepal.Length, data = iris, model = svmModel, kernel = "linear", fitted = FALSE,#
		control = mob_control(objfun = deviance, minsplit = 20, verbose = TRUE))
warnings()
expect_that(fit <- mob(Species ~ Sepal.Width | Sepal.Length, data = iris, model = svmModel, kernel = "linear", fitted = FALSE,#
		control = mob_control(objfun = deviance, minsplit = 20)), gives_warning("some groups are empty"))#
	terminal <- nodes(fit, max(where(fit)))#
	expect_equal(length(terminal[[1]]$model$scale[[1]]), 1)
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_mobSvmModel.R")
library(locClassData)#
	data <- vData(500)#
	fit <- mob(y ~ x.1 + x.2 | x.1 + x.2, data = data, model = svmModel, kernel = "linear", fitted = FALSE,#
		control = mob_control(objfun = deviance, minsplit = 200))
tr <- mean(predict(fit) != data$y)#
	ba <- mean(vBayesClass(data$x) != data$y)
tr
ba
expect_true(tr < ba + 0.05)
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_mobSvmModel.R")
warnings()
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_mobQdaModel.R")
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_kda.R")
fit <- kda(grouping = iris$Species, x = iris, wf = "gaussian", bw = 10) ## todo!!!
fit
expect_warning(predict(fit))
predict(fit)
source("/Users/juliaschiffner/Documents/locclass/locClass/skel/inst/tests/test_kda.R")
library(locClass)
gwf <- gaussian(bw = 1)
plot(gwf)
gwf <- gaussian(k = 100)
plot(gwf(1:150))
gwf <- gaussian(k = 100, nn.only = FALSE)
plot(gwf(1:150))
gwf <- gaussian(k = 100, bw = 1)
plot(gwf(1:150))
gwf <- gaussian(k = 100, bw = 10)
plot(gwf(1:150))
gwf <- gaussian(bw = 1)
gwf
x <- seq(0,1,0.01)
gwf <- gaussian(bw = 1)
gwf
plot(gwf(x))
curve(gwf(x))
gwf <- gaussian(k = 100)
gwf
curve(gwf(x))
gwf <- gaussian(k = 100, nn.only = FALSE)
gwf
gwf <- gaussian(k = 100, nn.only = FALSE)
gwf
curve(gwf(x))
x <- seq(0,1,0.01)
gwf <- gaussian(bw = 1)
gwf
curve(gwf(x))
gwf <- gaussian(k = 50)
gwf
curve(gwf(x))
gwf <- gaussian(k = 50, nn.only = FALSE)
gwf
curve(gwf(x))
gwf <- gaussian(k = 50, bw = 10)
gwf
curve(gwf(x))
gwf <- gaussian(k = 50, bw = 1)
gwf
curve(gwf(x))
gwf <- gaussian(bw = 1)
curve(gwf(x))
gwf <- gaussian(k = 50)
curve(gwf(x))
gwf <- gaussian(k = 50, nn.only = FALSE)
curve(gwf(x))
gwf <- gaussian(k = 50, bw = 1)
curve(gwf(x))
NAs in explanatory variables are ok#
	ran <- sample(1:150,100)#
	irisna <- iris#
	irisna[1:17,c(1,3)] <- NA#
	fit <- mob(Species ~ . | Sepal.Width, data = iris[ran,], model = qdaModel,#
		control = mob_control(objfun = deviance, minsplit = 30))#
	## sporadic try-errors in deviance.wqda: covariance singular#
	pred <- predict(fit, newdata = irisna) #
	## warnings: kein nicht-fehlendes Argument für max; gebe -Inf zurück#
	expect_true(all(is.na(pred[1:17])))
library(testthat)
NAs in explanatory variables are ok#
	ran <- sample(1:150,100)#
	irisna <- iris#
	irisna[1:17,c(1,3)] <- NA#
	fit <- mob(Species ~ . | Sepal.Width, data = iris[ran,], model = qdaModel,#
		control = mob_control(objfun = deviance, minsplit = 30))#
	## sporadic try-errors in deviance.wqda: covariance singular#
	pred <- predict(fit, newdata = irisna) #
	## warnings: kein nicht-fehlendes Argument für max; gebe -Inf zurück#
	expect_true(all(is.na(pred[1:17])))
NAs in splitting variable are not ok#
	irisna[1:17,1:3] <- NA#
	fit <- mob(Species ~ . | Sepal.Width, data = iris[ran,], model = qdaModel,#
		control = mob_control(objfun = deviance, minsplit = 30))#
	## sporadic try-errors in deviance.wqda: covariance singular#
	expect_error(pred <- predict(fit, newdata = irisna))
head(irisna)
pred <- predict(fit, newdata = irisna)
warnings()
libraryr(testthat)
library(testthat)
library(locClassMlr)
task <- makeClassifTask(data = iris, target = "Species")#
#
	# missing parameters#
	lrn <- makeLearner("classif.dannet")#
	expect_that(train(lrn, task), throws_error("either 'bw' or 'k' have to be specified"))#
#
	# default: reps = 1#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1)#
	train(lrn, task)#
	# reps = 3#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, reps = 3)#
	train(lrn, task)
lrn <- makeLearner("classif.dannet", bw = 2, size = 1)#
	tr1 <- train(lrn, task)#
	tr1$learner.model
lrn <- makeLearner("classif.dannet", bw = 2, size = 1, trace = FALSE)#
	tr1 <- train(lrn, task)#
	tr1$learner.model
lrn <- makeLearner("classif.dannet", bw = 2, size = 1, trace = FALSE)#
	tr1 <- train(lrn, task)#
	str(tr1$learner.model)
task <- makeClassifTask(data = iris, target = "Species")#
#
	# missing parameters#
	lrn <- makeLearner("classif.dannet")#
	expect_that(train(lrn, task), throws_error("either 'bw' or 'k' have to be specified"))#
#
	# default: reps = 1#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, trace = FALSE)#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$bw, 2)#
	expect_equal(tr1$learner.model$size, 1)#
	expect_equal(tr1$learner.model$trace, FALSE)#
	expect_equal(tr1$learner.model$reps, 1)#
	# reps = 3#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, reps = 3, trace = FALSE)#
	tr1 <- train(lrn, task)#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$bw, 2)#
	expect_equal(tr1$learner.model$size, 1)#
	expect_equal(tr1$learner.model$trace, FALSE)#
	expect_equal(tr1$learner.model$reps, 3)#
#
	Wts = runif(19, -0.5, 0.5)#
	# class prediction#
	lrn <- makeLearner("classif.dannet", par.vals = list(bw = 2, Wts = Wts, size = 2, trace = FALSE))#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$reps, 1)#
	pred1 <- predict(tr1, task = task)#
	tr2 <- dannet(Species ~ ., data = iris, bw = 2, Wts = Wts, size = 2, trace = FALSE)#
	expect_equal(tr2$reps, 1)#
	pred2 <- predict(tr2)#
	expect_equivalent(pred2$class, pred1$data$response)#
#
	# posterior prediction#
	lrn <- makeLearner("classif.dannet", par.vals = list(bw = 2, Wts = Wts, size = 2, trace = FALSE, reps = 3), predict.type = "prob")#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$reps, 3)#
	pred1 <- predict(tr1, task = task)#
	tr2 <- dannet(Species ~ ., data = iris, bw = 2, Wts = Wts, size = 2, trace = FALSE, reps = 3)#
	expect_equal(tr2$reps, 3)#
	pred2 <- predict(tr2)#
	expect_true(all(pred2$posterior == pred1$data[,3:5]))#
	expect_equivalent(pred2$class, pred1$data$response)
task <- makeClassifTask(data = iris, target = "Species")#
#
	# missing parameters#
	lrn <- makeLearner("classif.dannet")#
	expect_that(train(lrn, task), throws_error("either 'bw' or 'k' have to be specified"))#
#
	# default: reps = 1#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, trace = FALSE)#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$bw, 2)#
	expect_equal(tr1$learner.model$n[2], 1)#
	expect_equal(tr1$learner.model$trace, FALSE)#
	expect_equal(tr1$learner.model$reps, 1)#
	# reps = 3#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, reps = 3, trace = FALSE)#
	tr1 <- train(lrn, task)#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$bw, 2)#
	expect_equal(tr1$learner.model$n[2], 1)#
	expect_equal(tr1$learner.model$trace, FALSE)#
	expect_equal(tr1$learner.model$reps, 3)#
#
	Wts = runif(19, -0.5, 0.5)#
	# class prediction#
	lrn <- makeLearner("classif.dannet", par.vals = list(bw = 2, Wts = Wts, size = 2, trace = FALSE))#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$reps, 1)#
	pred1 <- predict(tr1, task = task)#
	tr2 <- dannet(Species ~ ., data = iris, bw = 2, Wts = Wts, size = 2, trace = FALSE)#
	expect_equal(tr2$reps, 1)#
	pred2 <- predict(tr2)#
	expect_equivalent(pred2$class, pred1$data$response)#
#
	# posterior prediction#
	lrn <- makeLearner("classif.dannet", par.vals = list(bw = 2, Wts = Wts, size = 2, trace = FALSE, reps = 3), predict.type = "prob")#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$reps, 3)#
	pred1 <- predict(tr1, task = task)#
	tr2 <- dannet(Species ~ ., data = iris, bw = 2, Wts = Wts, size = 2, trace = FALSE, reps = 3)#
	expect_equal(tr2$reps, 3)#
	pred2 <- predict(tr2)#
	expect_true(all(pred2$posterior == pred1$data[,3:5]))#
	expect_equivalent(pred2$class, pred1$data$response)
task <- makeClassifTask(data = iris, target = "Species")#
#
	# missing parameters#
	lrn <- makeLearner("classif.dannet")#
	expect_that(train(lrn, task), throws_error("either 'bw' or 'k' have to be specified"))#
#
	# default: reps = 1#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, trace = FALSE)#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$bw, 2)#
	expect_equal(tr1$learner.model$n[2], 1)#
	expect_equal(tr1$learner.model$reps, 1)#
	# reps = 3#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, reps = 3, trace = FALSE)#
	tr1 <- train(lrn, task)#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$bw, 2)#
	expect_equal(tr1$learner.model$n[2], 1)#
	expect_equal(tr1$learner.model$reps, 3)#
#
	Wts = runif(19, -0.5, 0.5)#
	# class prediction#
	lrn <- makeLearner("classif.dannet", par.vals = list(bw = 2, Wts = Wts, size = 2, trace = FALSE))#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$reps, 1)#
	pred1 <- predict(tr1, task = task)#
	tr2 <- dannet(Species ~ ., data = iris, bw = 2, Wts = Wts, size = 2, trace = FALSE)#
	expect_equal(tr2$reps, 1)#
	pred2 <- predict(tr2)#
	expect_equivalent(pred2$class, pred1$data$response)#
#
	# posterior prediction#
	lrn <- makeLearner("classif.dannet", par.vals = list(bw = 2, Wts = Wts, size = 2, trace = FALSE, reps = 3), predict.type = "prob")#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$reps, 3)#
	pred1 <- predict(tr1, task = task)#
	tr2 <- dannet(Species ~ ., data = iris, bw = 2, Wts = Wts, size = 2, trace = FALSE, reps = 3)#
	expect_equal(tr2$reps, 3)#
	pred2 <- predict(tr2)#
	expect_true(all(pred2$posterior == pred1$data[,3:5]))#
	expect_equivalent(pred2$class, pred1$data$response)
task <- makeClassifTask(data = iris, target = "Species")#
#
	# missing parameters#
	lrn <- makeLearner("classif.dannet")#
	expect_that(train(lrn, task), throws_error("either 'bw' or 'k' have to be specified"))#
#
	# default: reps = 1#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, trace = FALSE)#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$bw, 2)#
	expect_equal(tr1$learner.model$n[2], 1)#
	expect_equal(tr1$learner.model$reps, 1)#
	# reps = 3#
	lrn <- makeLearner("classif.dannet", bw = 2, size = 1, reps = 3, trace = FALSE)#
	tr1 <- train(lrn, task)#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$bw, 2)#
	expect_equal(tr1$learner.model$n[2], 1)#
	expect_equal(tr1$learner.model$reps, 3)#
#
	Wts = runif(19, -0.5, 0.5)
class prediction#
	lrn <- makeLearner("classif.dannet", par.vals = list(bw = 2, Wts = Wts, size = 2, trace = FALSE))#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$reps, 1)#
	pred1 <- predict(tr1, task = task)#
	tr2 <- dannet(Species ~ ., data = iris, bw = 2, Wts = Wts, size = 2, trace = FALSE)#
	expect_equal(tr2$reps, 1)#
	pred2 <- predict(tr2)#
	expect_equivalent(pred2$class, pred1$data$response)
posterior prediction#
	lrn <- makeLearner("classif.dannet", par.vals = list(bw = 2, Wts = Wts, size = 2, trace = FALSE, reps = 3), predict.type = "prob")#
	tr1 <- train(lrn, task)#
	expect_equal(tr1$learner.model$reps, 3)#
	pred1 <- predict(tr1, task = task)#
	tr2 <- dannet(Species ~ ., data = iris, bw = 2, Wts = Wts, size = 2, trace = FALSE, reps = 3)#
	expect_equal(tr2$reps, 3)#
	pred2 <- predict(tr2)#
	expect_true(all(pred2$posterior == pred1$data[,3:5]))#
	expect_equivalent(pred2$class, pred1$data$response)
?file.path
?wsvm
cluster <- kmeans(iris[,1], centers = 2)$cluster
fit <- flexmix(Species ~ Sepal.Width, data = iris, concomitant = FLXPmultinom(~ Sepal.Length), model = FLXMCLsvm(kernel = "linear", fitted = FALSE), cluster = cluster, control = list(iter.max = 200, classify = "weighted", verb = 1))
fit <- flexmix(Species ~ Sepal.Width, data = iris, concomitant = FLXPmultinom(~ Sepal.Length), model = FLXMCLsvm(kernel = "linear", fitted = FALSE), cluster = cluster, control = list(iter.max = 200, classify = "hard", verb = 1))
iris$Species <- as.numeric(iris$Species)#
	cluster <- kmeans(iris[,c(1,3)], centers = 2)$cluster#
	expect_that(tr2 <- flexmix(Species ~ Sepal.Length, data = iris, concomitant = FLXPmultinom(~ Petal.Length + Sepal.Length), model = FLXMCLsvm(kernel = "linear", fitted = FALSE, tolerance = 10^-6), cluster = cluster, control = list(iter.max = 50, classify = "weighted", tolerance = 10^-4, verb = 1)), gives_warning("'grouping' was coerced to a factor"))
tr2 <- flexmix(Species ~ Sepal.Length, data = iris, concomitant = FLXPmultinom(~ Petal.Length + Sepal.Length), model = FLXMCLsvm(kernel = "linear", fitted = FALSE, tolerance = 10^-6)
, cluster = cluster, control = list(iter.max = 50, classify = "weighted", tolerance = 10^-4, verb = 1))
system.time(replicate(1000,wsvm(Species ~ ., data = iris, kernel = "linear", tolerance = 10^-6)))
system.time(replicate(1000,wsvm(Species ~ ., data = iris, kernel = "linear")))
help(package = "locClass")
library(flexmix)
?filConcomitant
?fillConcomitant
?FLXfillConcomitant
help(package = "locClass")
library(locClass)
??FLXMCLconstantGenerative
??FLXMCLconstant
?FLXMCLconstantGenerative
library(benchData)#
data <- flashData(1000)#
x1 <- seq(-6,6,0.2)#
x2 <- seq(-4,4,0.2)#
grid <- expand.grid(x.1 = x1, x.2 = x2)#
#
cluster <- kmeans(data$x, center = 4)$cluster#
model <- FLXMCLconstantGenerative()#
fit <- flexmix(y ~ ., data = as.data.frame(data), model = model, cluster = cluster, control = list(verb = 1))
traceback()
source("/Users/juliaschiffner/Documents/locClassGithub/locClass/R/FLXMCLconstantGenerative.R")
library(benchData)#
data <- flashData(1000)#
x1 <- seq(-6,6,0.2)#
x2 <- seq(-4,4,0.2)#
grid <- expand.grid(x.1 = x1, x.2 = x2)#
#
cluster <- kmeans(data$x, center = 4)$cluster#
model <- FLXMCLconstantGenerative()#
fit <- flexmix(y ~ ., data = as.data.frame(data), model = model, cluster = cluster, control = list(verb = 1))
source("/Users/juliaschiffner/Documents/locClassGithub/locClass/R/FLXMCLconstantGenerative.R")
library(benchData)#
data <- flashData(1000)#
x1 <- seq(-6,6,0.2)#
x2 <- seq(-4,4,0.2)#
grid <- expand.grid(x.1 = x1, x.2 = x2)#
#
cluster <- kmeans(data$x, center = 4)$cluster#
model <- FLXMCLconstantGenerative()#
fit <- flexmix(y ~ ., data = as.data.frame(data), model = model, cluster = cluster, control = list(verb = 1))
fit
pred.grid <- predict(fit, newdata = grid)
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[1]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
image(x1, x2, matrix(pred.grid[[2]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[2]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
pred.grid <- lapply(pred.grid, function(x) x/rowSums(x))
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[1]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
pred.grid <- predict(fit, newdata = grid)
head(pred.grid)
head(pred.grid[[1]])
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[1]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
image(x1, x2, matrix(pred.grid[[2]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[2]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
image(x1, x2, matrix(pred.grid[[3]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[3]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
image(x1, x2, matrix(pred.grid[[4]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[4]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
pred.grid <- lapply(pred.grid, function(x) x/rowSums(x))
head(pred.grid[[1]])
head(pred.grid[[1]],50)
head(pred.grid[[2]],50)
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
pred.grid <- mypredict(fit, newdata = grid, aggregate = TRUE)
pred.grid
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[1]][,1], length(x1)), add  = TRUE)
points(data$x, pch = as.character(data$y))
pred.grid <- lapply(pred.grid, function(x) x/rowSums(x))
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[1]][,1], length(x1)), add  = TRUE)
points(data$x, pch = as.character(data$y))
pred.grid <- predict(fit, newdata = grid)
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[1]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
image(x1, x2, matrix(pred.grid[[2]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[2]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
image(x1, x2, matrix(pred.grid[[3]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[3]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
image(x1, x2, matrix(pred.grid[[4]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[4]][,1], length(x1)), add = TRUE)
points(data$x, pch = as.character(data$y))
pred.grid <- lapply(pred.grid, function(x) x/rowSums(x))
head(pred.grid[[1]])
head(pred.grid[[2]])
head(pred.grid[[3]])
head(pred.grid[[4]])
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
pred.grid <- mypredict(fit, newdata = grid, aggregate = TRUE)
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[1]][,1], length(x1)), add  = TRUE)
points(data$x, pch = as.character(data$y))
pred.grid <- lapply(pred.grid, function(x) x/rowSums(x))
image(x1, x2, matrix(pred.grid[[1]][,1], length(x1)))
contour(x1, x2, matrix(pred.grid[[1]][,1], length(x1)), add  = TRUE)
points(data$x, pch = as.character(data$y))
grid <- cbind(y = flashBayesClass(grid), grid)
loc.grid <- posterior(fit, newdata = grid)
contour(x1, x2, matrix(loc.grid[,1], length(x1)), add  = TRUE)
