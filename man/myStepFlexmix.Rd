% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/myStepFlexmix.R
\name{myStepFlexmix}
\alias{myStepFlexmix}
\title{Run \code{\link[flexmix]{flexmix}} Repeatedly}
\usage{
myStepFlexmix(..., cluster, verbose = FALSE, drop = TRUE, unique = FALSE)
}
\arguments{
\item{cluster}{List of initial cluster assignments of observations at the start of the EM algorithm.}

\item{verbose}{If \code{TRUE}, show progress information during computations.}

\item{drop}{If \code{TRUE} and k is of length 1, then a single flexmix object is returned instead of a "stepFlexmix" object.}

\item{unique}{If \code{TRUE}, then \code{unique()} is called on the result, see below.}

\item{\dots}{Passed to \code{\link[flexmix]{flexmix}}.}
}
\value{
An object of class \code{"stepFlexmix"} containing the best models with respect to the log likelihood for the different number of components in a slot if \code{length(k)>1}, else directly an object of class \code{"flexmix"}.
If \code{unique=FALSE}, then the resulting object contains one model per element of \code{k} (which is the number of clusters the EM algorithm started with). 
If \code{unique=TRUE}, then the result is resorted according to the number of clusters contained in the fitted models (which may be less than the number with which 
the EM algorithm started), and only the maximum likelihood solution for each number of fitted clusters is kept. This operation can also be done manually by 
calling \code{unique()} on objects of class \code{"stepFlexmix"}.
}
\description{
Runs \code{\link[flexmix]{flexmix}} repeatedly for different cluster values and returns the result with highest likelihood value.
}
\examples{
library(benchData)
data <- xor3Data(500)
model <- FLXMCLmultinom(trace = FALSE, decay = 0.1)
cluster <- lapply(1:5, kmeans(data$x, centers = 3)$cluster)
fit <- myStepFlexmix(y ~ ., data = as.data.frame(data), concomitant = FLXPmultinom(~ x.1 + x.2), model = model, 
    cluster = cluster, control = list(verb = 1, tolerance = 10^-1))
fit2 <- flexmix(y ~ ., data = as.data.frame(data), concomitant = FLXPmultinom(~ x.1 + x.2), model = model, 
    cluster = posterior(fit), control = list(verb = 1))
pred <- mypredict(fit2, aggregate = TRUE)
mean(max.col(pred[[1]]) != data$y)
}
\seealso{
Other mixtures: \code{\link{FLXMCL-class}},
  \code{\link{FLXPwlda-class}}, \code{\link{FLXPwlda}},
  \code{\link{myfitted}}, \code{\link{mypredict}}
}

