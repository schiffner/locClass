% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/daqda.R
\name{daqda}
\alias{daqda}
\alias{daqda.data.frame}
\alias{daqda.default}
\alias{daqda.formula}
\alias{daqda.matrix}
\title{Discriminant Adaptive Quadratic Discriminant Analysis}
\usage{
daqda(x, ...)

\method{daqda}{formula}(formula, data, weights = rep(1, nrow(data)), ...,
  subset, na.action)

\method{daqda}{data.frame}(x, ...)

\method{daqda}{matrix}(x, grouping, weights = rep(1, nrow(x)), ..., subset,
  na.action = na.fail)

\method{daqda}{default}(x, grouping, wf = c("biweight", "cauchy", "cosine",
  "epanechnikov", "exponential", "gaussian", "optcosine", "rectangular",
  "triangular"), bw, k, nn.only, itr = 3, weights, ...)
}
\arguments{
\item{x}{(Required if no \code{formula} is given as principal argument.) A \code{matrix} or \code{data.frame} or \code{Matrix} containing the explanatory variables.}

\item{formula}{A formula of the form \code{groups ~ x1 + x2 + \dots}, that is, the response
is the grouping \code{factor} and the right hand side specifies the (normally non-\code{factor})
discriminators.}

\item{data}{A \code{data.frame} from which variables specified in \code{formula} are to be taken.}

\item{weights}{Initial observation weights (defaults to a vector of 1s).}

\item{subset}{An index vector specifying the cases to be used in the training sample. (NOTE: If given, this argument must be named.)}

\item{na.action}{A function to specify the action to be taken if NAs are found. The default action is first
the \code{na.action} setting of \code{\link{options}} and second \code{\link{na.fail}} if that is unset. 
An alternative is \code{\link{na.omit}}, which leads to rejection of cases with missing values on any required 
variable. (NOTE: If given, this argument must be named.)

If the predictor variables include factors, the formula interface must be used in order 
to get a correct model matrix.}

\item{grouping}{(Required if no \code{formula} is given as principal argument.) A \code{factor} specifying
the class membership for each observation.}

\item{wf}{A window function which is used to calculate weights that are introduced into 
the fitting process. Either a character string or a function, e.g. \code{wf = function(x) exp(-x)}.
For details see the documentation for \code{\link[=biweight]{wfs}}.}

\item{bw}{(Required only if \code{wf} is a string.) The bandwidth parameter of the window function. (See \code{\link[=biweight]{wfs}}.)}

\item{k}{(Required only if \code{wf} is a string.) The number of nearest neighbors of the decision boundary to be used in the fitting process. (See \code{\link[=biweight]{wfs}}.)}

\item{nn.only}{(Required only if \code{wf} is a string indicating a window function with infinite support and if \code{k} is specified.) Should
only the \code{k} nearest neighbors or all observations receive positive weights? (See \code{\link[=biweight]{wfs}}.)}

\item{itr}{Number of iterations for model fitting, defaults to 3. See also the Details section.}

\item{\dots}{Further arguments to be passed to \code{\link{wqda}}.}
}
\value{
An object of class \code{"daqda"} inheriting from \code{"wqda"}, a \code{list} containing the following components:
 \item{prior}{Weighted class prior probabilities.}
 \item{counts}{The number of observations per class.}
 \item{means}{Weighted estimates of class means.}
 \item{cov}{Weighted estimate of the pooled class covariance matrix.}
 \item{lev}{The class labels (the levels of \code{grouping}).}  
 \item{N}{The number of training observations.}
 \item{weights}{A list of length \code{itr + 1}. The initial observation weights (a vector of 1s if none were given) and the observation
  weights calculated in the individual iterations. The weights are scaled such that they sum up to 1.}
	\item{method}{The method used for scaling the pooled weighted covariance matrix.}
 \item{itr}{The number of iterations used.}
 \item{wf}{The window function used. Always a function, even if the input was a string.}
 \item{bw}{(Only if \code{wf} is a string or was generated by means of one of the functions documented in \code{\link[=biweight]{wfs}}.) 
  The bandwidth used, \code{NULL} if \code{bw} was not specified.}
\item{k}{(Only if \code{wf} is a string or was generated by means of one of the functions documented in \code{\link[=biweight]{wfs}}.) 
  The number of nearest neighbors used, \code{NULL} if \code{k} was not specified.}
 \item{nn.only}{(Logical. Only if \code{wf} is a string or was generated by means of one of the functions documented in \code{\link[=biweight]{wfs}} and if \code{k} was
 specified.) \code{TRUE} if only the \code{k} nearest neighbors receive a positive weight, \code{FALSE} otherwise.}
 \item{adaptive}{(Logical.) \code{TRUE} if the bandwidth of \code{wf} is adaptive to the local density of data points, \code{FALSE} if the bandwidth
  is fixed.}
 \item{call}{The (matched) function call.}
}
\description{
A local version of Quadratic Discriminant Analysis that puts increased emphasis on a good model fit near the decision boundary.
}
\details{
The idea of Hand and Vinciotti (2003) to put increased weight on observations near the decision boundary is generalized to the multiclass case and applied to 
Quadratic Discriminant Analysis (QDA).
Since the decision boundary is not known in advance an iterative procedure is required.
First, an unweighted QDA is fitted to the data. 
Based on the differences between the two largest estimated posterior probabilities observation weights are calculated.
Then a weighted QDA (see \code{\link{wqda}}) is fitted using these weights. 
Calculation of weights and model fitting is done several times in turn. 
The number of iterations is determined by the \code{itr}-argument that defaults to 3.

The name of the window function (\code{wf}) can be specified as a character string.
In this case the window function is generated internally in \code{daqda}. Currently
supported are \code{"biweight"}, \code{"cauchy"}, \code{"cosine"}, \code{"epanechnikov"}, 
\code{"exponential"}, \code{"gaussian"}, \code{"optcosine"}, \code{"rectangular"} and 
\code{"triangular"}.

Moreover, it is possible to generate the window functions mentioned above in advance 
(see \code{\link[=biweight]{wfs}}) and pass them to \code{daqda}.

Any other function implementing a window function can also be used as \code{wf} argument.
This allows the user to try own window functions.
See help on \code{\link[=biweight]{wfs}} for details.
}
\examples{
fit <- daqda(Species ~ Sepal.Length + Sepal.Width, data = iris,
    wf = "gaussian", bw = 0.5)
pred <- predict(fit)
mean(pred$class != iris$Species)

}
\references{
Hand, D. J., Vinciotti, V. (2003), Local versus global models for classification problems: 
Fitting models where it matters, \emph{The American Statistician}, \bold{57(2)} 124--130.
}
\seealso{
\code{\link{predict.daqda}}, \code{\link{wqda}} for a weighted version of Quadratic Discriminant Analysis and \code{\link{dalr}} for discriminant adaptive logistic regression.
}
\keyword{classif}
\keyword{multivariate}

